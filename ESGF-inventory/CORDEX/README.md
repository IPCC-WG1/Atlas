# ESGF CORDEX inventories

Inventories are generated by `time_frequency`.

## Unique inventory

jq can be used to create an unique inventory combining daily and fixed `time_frequency` values. Here we show how (just for reference).

```
jq -r --slurp --arg variables "${variables}" '
	map(. + map_values(arrays|first)) | 
	map(select(.replica == false)) |

	map(. + { dataset_all_runs: (.master_id|split(".")|del(.[6,9,10])|join(".")) }) |
	group_by(.dataset_all_runs) |
	map( {	dataset_all_runs: .[0].dataset_all_runs,
			time: map(select(.time_frequency != "fx")),
			fixed: map(select(.time_frequency == "fx")) }) |

	map(.time |= group_by(.ensemble)) |
	map(.time |= map({ensemble: .[0].ensemble, size: map(.size)|add, variables: map(.variable)})) |
	map(.fixed |= {ensemble: .[0].ensemble, size: map(.size)|add, variables: map(.variable)}) |

	map({dataset_all_runs, variables: [.time, [.fixed]]|combinations}) |
	map({dataset_id:
			((.dataset_all_runs|split(".")[:6]) +
			[(.variables|map(select(.ensemble != "r0i0p0"))|map(.ensemble)|first)] +
			(.dataset_all_runs|split(".")[6:])) | join("."),
		size: .variables|map(.size)|add,
		variables: .variables|map(.variables)|add}) |

	(reduce ($variables|split(","))[] as $v ({}; . + {($v): false})) as $false_variables |
	map(reduce .variables[] as $v ({dataset_id, size} + $false_variables; . + {($v): true})) |

	(["dataset_id", "size"] + ($variables|split(",")|sort)) as $keys | $keys, map([.[ $keys[] ]])[] | @csv'
```
